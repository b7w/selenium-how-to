Пример 1
========

Для первого примера давайте найдем все ссылки из колонок на странице "Lab 1" и перейдем по ним.
А так же проверим что текст в ссылке присутствует на открытых страницах.

Рассмотрим первый метод *test_follow_links* класса *Lab1Test*.
Первой строчкой мы говорим драйверу загрузить страницу, передавая url. Второй строчкой мы сверяем заголовок.

    self.driver.get(self.base_url + '/lab1/')
    self.assertTitle('lab 1')

Дальше мы открывает FireFox и в коде HTML находим, что все три колонки находятся в одном блоке *div* с классом *row-fluid*.
Соответственно мы можем найти все необходимые нам ссылки таким запросом *.row-fluid a*. Но есть одна тонкость.
Мы найдем объекты, но у них может не оказаться атрибута href с ссылкой. Поэтому мы изменим запрос на *.row-fluid a[href]*.
Конечно это не даст гарантии, что ссылка будет правильной и не будет являтся заглушкой вида *#*.
Но мы однозначно не получим ошибку с доступом к атрибуту по имени.
Более точное поведение стоит обработать уже на уровне программирования. Например с помощью регулярных выражений.

Далее мы получаем элементы. А если быть совсем точным указатели на элементы страницы.
Поэтому нам необходимо сохранить, данные которые нам нужны. Ибо при загрузке новой странички, наши указатели будут не валидными.
Что мы в цикле и делаем, добавляя к списку пары значений: отображаемый текст ссылки в малом регистре и саму ссылку.
Регистр нам важен для правильного сравнения строк.

    elements = self.find_all(css='.row-fluid a[href]')
    links = []
    for item in elements:
        href = item.get_attribute('href')
        links.append((item.text.lower(), href))

После мы делаем первую проверку с оператором assert на количество ссылок в массиве.
Assert принимает первым параметром булево значение. Если оно ложно, то исключение будет брошено.
Далее после запятой можно указать выражение, которое будет служить сообщением при ошибке.

    assert len(links) == 9, len(links)

В следующем цикле мы итерируемся по нашим данными. Говорим драйверу, что бы он открыл страничку.
Сохраняем исходный текст, HTML код, в малом регистре для дальнейшего поиска.
Разбиваем текст ссылки на отдельные слова, отделенные пробелами. И проверяем, что каждое слово присутствует на странице.
Далее находим элемент *span* с классом *name* и проверяем что его содержимое равно имени ссылки без пробелов.

    source = self.driver.page_source.lower()
    for word in text.split():
        assert word in source
        assert self.find(css='span.name').text.lower() == text.replace(' ', '')

Рассмотрим второй метод *test_resource*. В нем мы хотим проверить доступны ли все ресурсы и ссылки на странице.
К сожалению это не возможно сделать с помощью браузера. Поэтому мы напишем простой дополнительный метод.
Он будет использовать стандартный HTTP протокол для получения статуса. Если статус равен 200 - все ок.
Все статусы можно посмотреть [тут](ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP).

Метод *http_status*, приминает ссылку. Второй строкой в нем мы создаем экземпляр класса,
передав ему домен (например 127.0.0.1) к которому надо подключиться и максимальное время ожидания.
Далее мы формируем запрос c типом *HEAD* и относительным путем (например /static/favicon.ico).
Этот тип запроса позволит не загружать все данные, только информацию о веб страничке.
В конце делаем запрос и получаем статус. Все.

    host = urlsplit(url)
    conn = HTTPConnection(host.netloc, timeout=8)
    conn.request('HEAD', host.path)
    res = conn.getresponse()
    return res.status

В самом тестовом методе у нас простые запросы. На получение всех изображений, стилей, скриптов и страниц.
Из полученных данных мы достаем ссылки и в цикле сверяем статут.
Единственное, нам надо контролировать что они начинаются на *http:*.
Так как есть и url для создания почтовых сообщений и даже открытия программ.

    for item in self.find_all(css='img[src]'):
        assert self.http_status(item.get_attribute('src')) == 200
